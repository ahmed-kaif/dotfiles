local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("asm", { -- "asm" is the filetype for assembly code in Neovim
  s("template", {
    t({
      ".model small",
      ".stack 100h",
      ".data",
      "",
      ".code",
      "main proc",
      "    mov ax,@data",
      "    mov ds,ax ",
      "",
      "    mov ah,4ch",
      "    int 21h",
      "main endp",
      "end main",
    }),
    t({ "", "" }),
    i(0) -- Final cursor position
  }),
  s("datainit", {
    t({
      "mov ax,@data",
      "mov ds,ax",
    }),
  }),
  s("input", {
    t({
      "mov ah,1h",
      "int 21h",
    }),
  }),
  s("output", {
    t({
      "mov ah,2h",
      "mov dl,",
    }),
    i(1, "char"),
    t({ "",
      "int 21h", }),
    i(0)
  }),
  s("display_str", {
    t({
      "display_str_:",
      "    mov cx,5",
      "    lea si,str2",
      "    mov ah,2",
      "print_:",
      "    lodsb",
      "    mov dl,al",
      "    int 21h",
      "    loop print_",
    })
  }),
  s("proc read_str", {
    t({
      "read_str proc near",
      "; reads and stores a string",
      "; input: DI offset of a string",
      "; output: DI offset of string",
      "; BX is the no. of chars to read",
      "    push ax",
      "    push di ",
      "    cld",
      "    xor bx,bx",
      "    mov ah,1",
      "    int 21h",
      "while_:",
      "    cmp al,0dh",
      "    je end_while_",
      "; if char is BACKSPACE ",
      "    cmp al,8h",
      "    jne else_    ; no, store in the string",
      "; then",
      "    dec di      ; yes, a backspace so mov str ptr back",
      "    dec bx      ; decrement char counter",
      "    jmp read_   ; go to read another char",
      "else_:",
      "    stosb       ; store char in string",
      "    inc bx      ; increase char count",
      "",
      "read_:",
      "    int 21h",
      "    jmp while_",
      "",
      "end_while_:",
      "    pop di ",
      "    pop ax ",
      "    ret",
      "read_str endp",
    }),
    t({ "", "" }),
    i(0), -- Final cursor position
  }),
  s("proc outdec", {
    t({
      "outdec proc",
      "; prints ax as a signed decimal integer",
      "; input AX",
      "; output none",
      "    push bx",
      "    push cx",
      "    push dx",
      "; if AX < 0",
      "    or ax,ax        ; ax < 0 ?",
      "    jge @end_if_    ; no, > 0",
      "; then",
      "    push ax",
      "    mov dl,'-'",
      "    mov ah,2",
      "    int 21h         ; print negative sign",
      "    pop ax",
      "    neg ax          ; ax = -ax",
      "@end_if_:",
      "; get decimal digits",
      "    xor cx,cx       ; cx counts digits",
      "    mov bx,10d      ; bx has divisor = 10 ",
      "@repeat_:",
      "    xor dx,dx       ; dx:ax / bx so dx has remainder",
      "    div bx          ; ax = quotient, dx = remainder",
      "    push dx         ; save rem on stack",
      "    inc cx          ; digit count++",
      "; until",
      "    or ax,ax        ; is ax = 0 ?",
      "    jne @repeat_    ; ax is not zero so keep going",
      "; convert digits to chars and print",
      "    mov ah,2",
      "; for count times do ",
      "@print_loop_:",
      "    pop dx",
      "    or dl,30h",
      "    int 21h",
      "    loop @print_loop_",
      "; end for ",
      "    pop dx",
      "    pop cx",
      "    pop bx",
      "    ret",
      "outdec endp",
    }),
    t({ "", "" }),
    i(0), -- Final cursor position
  }),
  s("proc indec", {
    t({
      "indec proc",
      "; reads a number in range -32768 to 32767",
      "; input: none",
      "; output: AX = binary equivalent of the number",
      "    push bx",
      "    push cx",
      "    push dx",
      "@begin_:",
      "; total = 0",
      "    xor bx,bx           ; bx holds total",
      "; is_neg = false",
      "    xor cx,cx           ; cx holds sign",
      "; read a char",
      "    mov ah,1",
      "    int 21h",
      "; case of char",
      "    cmp al,'-'",
      "    je @minus_",
      "    cmp al,'+'",
      "    je @plus_",
      "    jmp @repeat_in_    ; start processing chars",
      "@minus_:",
      "    mov cx,1           ; is_neg = true",
      "@plus_:",
      "    int 21h            ; read char",
      "; end case",
      "@repeat_in_:",
      "; if char 0..9",
      "    cmp al,'0'         ; char >= '0'",
      "    jnge @not_digit_",
      "    cmp al,'9'",
      "    jnle @not_digit_",
      "; then convert to digit",
      "    and ax,000fh       ; convert to digit",
      "    push ax            ; push digit on stack",
      "; total = total x 10 + digit",
      "    mov ax,10d",
      "    mul bx             ; ax = total x 10",
      "    pop bx             ; bx = digit",
      "    add bx,ax          ; total = total x 10 + digit",
      "; read a char",
      "    mov ah,1",
      "    int 21h",
      "    cmp al,0dh         ; is carriage return?",
      "    je @calc_          ; yes, stop taking input",
      "    cmp al,20h         ; is space?",
      "    je @calc_          ; yes, stop taking input",
      "    jne @repeat_in_    ; no, keep taking input",
      "; until CR or SPACE",
      "@calc_:",
      "    mov ax,bx          ; store the number in ax",
      "; if negative",
      "    or cx,cx           ; is negative number",
      "    je @exit_          ; no, exit",
      "; then",
      "    neg ax             ; yes negative",
      "@exit_:",
      "    pop dx",
      "    pop cx",
      "    pop bx",
      "    ret",
      "; if not a digit",
      "@not_digit_:",
      "    mov ah,2",
      "    mov dl,0dh",
      "    int 21h",
      "    mov dl,0ah",
      "    int 21h",
      "    jmp @begin_",
      "indec endp",
    }),
    t({ "", "" }),
    i(0), -- Final cursor position
  }),
  s("exit", {
    t({
      "mov ah,4ch",
      "int 21h"
    }),
  }),
})
